<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    #viewer {
      width: 100%;
      height: 100vh;
    }

    #sidebar {
      position: absolute;
      top: 0;
      left: 0;
      width: 300px;
      height: 100vh;
      background: rgba(255, 255, 255, 0.95);
      border-right: 1px solid #ccc;
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
    }

    #sidebar h3 {
      margin: 0 0 10px 0;
      padding-bottom: 10px;
      border-bottom: 2px solid #333;
    }

    .tree-item {
      padding: 4px 0;
      cursor: pointer;
      user-select: none;
    }

    .tree-item:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .tree-item-content {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .tree-toggle {
      width: 16px;
      text-align: center;
      font-size: 12px;
      color: #666;
    }

    .tree-checkbox {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .tree-label {
      flex: 1;
      font-size: 14px;
    }

    .tree-children {
      margin-left: 20px;
      display: none;
    }

    .tree-children.expanded {
      display: block;
    }

    .tree-item.hidden .tree-label {
      color: #999;
      text-decoration: line-through;
    }

    #viewControls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(3, 60px);
      gap: 5px;
    }

    .view-btn {
      padding: 8px;
      border: 1px solid #666;
      background: white;
      cursor: pointer;
      font-size: 12px;
      border-radius: 3px;
      transition: background 0.2s;
    }

    .view-btn:hover {
      background: #f0f0f0;
    }

    .view-btn:active {
      background: #e0e0e0;
    }

    #loadingOverlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    #loadingOverlay .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #ccc;
      border-top-color: #333;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    #loadingOverlay p {
      margin-top: 16px;
      font-size: 14px;
      color: #333;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>PosiViewer3D</h3>
    <div id="tree"></div>
  </div>
  <div id="viewControls">
    <button class="view-btn" onclick="setView('home')">Home</button>
    <button class="view-btn" onclick="setView('top')">Top</button>
    <button class="view-btn" onclick="setView('front')">Front</button>
    <button class="view-btn" onclick="setView('right')">Right</button>
    <button class="view-btn" onclick="setView('bottom')">Bottom</button>
    <button class="view-btn" onclick="setView('back')">Back</button>
    <button class="view-btn" onclick="setView('left')">Left</button>

    <hr style="grid-column: span 3; border: none; border-top: 1px solid #ccc; margin: 2px 0;">
    
    <button class="view-btn" onclick="zoom(0.2)" style="grid-column: span 1;">Zoom -</button>
    <button class="view-btn" onclick="zoom(-0.2)" style="grid-column: span 1;">Zoom +</button>
  </div>
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <p id="loadingText">Loading model...</p>
  </div>
  <canvas id="viewer"></canvas>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/DRACOLoader.js';

    const canvas = document.getElementById('viewer');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xFFFFFF);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(2, 2, 2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Store model bounds globally for view controls
    let modelCenter = new THREE.Vector3();
    let modelSize = 1;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.75);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.75);
    dir.position.set(5, 10, 7);
    scene.add(dir);
    //const ambient = new THREE.AmbientLight(0xffffff, 0.3);
    //scene.add(ambient);

    // Draco loader for compressed geometry
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
    dracoLoader.setDecoderConfig({ type: 'js' });

    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);

    gltfLoader.load('/models/V0test.glb', (gltf) => {
      const root = gltf.scene;
      scene.add(root);

      const box = new THREE.Box3().setFromObject(root);
      modelSize = box.getSize(new THREE.Vector3()).length();
      modelCenter = box.getCenter(new THREE.Vector3());

      controls.target.copy(modelCenter);
      camera.position.copy(modelCenter).add(new THREE.Vector3(modelSize, modelSize, modelSize));
      camera.updateProjectionMatrix();

      // Build the tree hierarchy UI
      buildTree(root);
      document.getElementById('loadingOverlay').remove();
    }, (progress) => {
      if (progress.total) {
        const pct = (progress.loaded / progress.total * 100).toFixed(0);
        document.getElementById('loadingText').textContent = `Loading model... ${pct}%`;
      }
    }, (error) => {
      console.error('Error loading model:', error);
      document.getElementById('loadingText').textContent = 'Failed to load model.';
    });

    function buildTree(root) {
      const treeContainer = document.getElementById('tree');
      treeContainer.innerHTML = '';

      function createTreeItem(obj, parentElement) {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'tree-item';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'tree-item-content';

        // Toggle arrow for items with children
        const toggleSpan = document.createElement('span');
        toggleSpan.className = 'tree-toggle';
        if (obj.children && obj.children.length > 0) {
          toggleSpan.textContent = '▶';
        }
        contentDiv.appendChild(toggleSpan);

        // Visibility checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'tree-checkbox';
        checkbox.checked = obj.visible;
        checkbox.addEventListener('change', (e) => {
          obj.visible = e.target.checked;
          if (e.target.checked) {
            itemDiv.classList.remove('hidden');
          } else {
            itemDiv.classList.add('hidden');
          }
        });
        contentDiv.appendChild(checkbox);

        // Object name/type
        const label = document.createElement('span');
        label.className = 'tree-label';
        let name = obj.name || obj.type || 'Object';
        if (obj.isMesh) {
          name += ' (mesh)';
        } else if (obj.isGroup) {
          name += ' (group)';
        }
        label.textContent = name;
        contentDiv.appendChild(label);

        itemDiv.appendChild(contentDiv);

        // Children container
        if (obj.children && obj.children.length > 0) {
          const childrenDiv = document.createElement('div');
          childrenDiv.className = 'tree-children';

          // Add toggle functionality
          toggleSpan.addEventListener('click', () => {
            childrenDiv.classList.toggle('expanded');
            toggleSpan.textContent = childrenDiv.classList.contains('expanded') ? '▼' : '▶';
          });

          // Recursively add children
          obj.children.forEach(child => {
            createTreeItem(child, childrenDiv);
          });

          itemDiv.appendChild(childrenDiv);
        }

        parentElement.appendChild(itemDiv);
      }

      createTreeItem(root, treeContainer);
    }

    // View control function
    window.setView = function(view) {
      const distance = modelSize * 1.5;
      controls.target.copy(modelCenter);

      switch(view) {
        case 'top':
          camera.position.set(modelCenter.x, modelCenter.y + distance, modelCenter.z);
          camera.up.set(0, 0, -1);
          break;
        case 'bottom':
          camera.position.set(modelCenter.x, modelCenter.y - distance, modelCenter.z);
          camera.up.set(0, 0, 1);
          break;
        case 'front':
          camera.position.set(modelCenter.x, modelCenter.y, modelCenter.z + distance);
          camera.up.set(0, 1, 0);
          break;
        case 'back':
          camera.position.set(modelCenter.x, modelCenter.y, modelCenter.z - distance);
          camera.up.set(0, 1, 0);
          break;
        case 'right':
          camera.position.set(modelCenter.x + distance, modelCenter.y, modelCenter.z);
          camera.up.set(0, 1, 0);
          break;
        case 'left':
          camera.position.set(modelCenter.x - distance, modelCenter.y, modelCenter.z);
          camera.up.set(0, 1, 0);
          break;
        case 'iso':
          camera.position.set(
            modelCenter.x + distance * 0.7,
            modelCenter.y + distance * 0.7,
            modelCenter.z + distance * 0.7
          );
          camera.up.set(0, 1, 0);
          break;
        case 'home':
          camera.position.set(
            modelCenter.x + modelSize,
            modelCenter.y + modelSize,
            modelCenter.z + modelSize
          );
          camera.up.set(0, 1, 0);
          break;
      }

      camera.lookAt(modelCenter);
      camera.updateProjectionMatrix();
      controls.update();
    };

    // Zoom function
    window.zoom = function(factor) {
      // Calculate direction from target to camera
      const direction = new THREE.Vector3();
      direction.subVectors(camera.position, controls.target);

      // Scale the direction by the factor
      const newDistance = direction.length() * (1 + factor);

      // Prevent zooming too close or too far
      const minDistance = modelSize * 0.1;
      const maxDistance = modelSize * 10;

      if (newDistance >= minDistance && newDistance <= maxDistance) {
        direction.normalize().multiplyScalar(newDistance);
        camera.position.copy(controls.target).add(direction);
        camera.updateProjectionMatrix();
      }
    };

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  </script>
</body>
</html>
